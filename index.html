<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Intro to FP (slides)</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <link rel="icon" href="favicon.png">
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown>
          <script type="text/template">
          # Introduction to functional programming

          <small>Created by [Matt Newman](http://mdjnewman.me/) for the April
          2017 [Women Who Code Brisbane](https://www.meetup.com/Women-Who-Code-Brisbane/)
          meetup</small>
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
          ## What I'll be talking about

          - Comparision of different paradigms
          - What is functional programming?
          - Purity
          - Common higher-order functions
          - Declarative programming
          </script>
        </section>
        <section data-markdown>
          <script type="text/template">
          ## What I won't be talking about

          - Type/category theory
          - Laziness

          <small>I do think all these things are awesome, so come talk to me
          afterwards if you'd like</small>
          </script>
        </section>
        <section>
          <section data-markdown>
            <script type="text/template">
            ## What are 'paradigms'?

            Note:
            A paradigm is a style of building the structure and elements of
            computer programs.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            Different paradigms:

            - Procedural
            - Object oriented
            - Functional
            - Logical
            - Symbolic
            - Dataflow
            - â€¦
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            ### Prodecural

            Structued BASIC and C are notable examples, they provide looping and
            subroutines.

            *Why?*

            To abstract away from GOTO statements.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            ### Object oriented

            Java, C#, C++ etc, these languages gave us classes and objects.

            *Why?*

            To abstract away from global state.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            ### Functional

            Increasingly large number of languages, including Clojure,
            Scala and Haskell.

            *Why?*

            To abstract away from all state.
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            Note that the paradigms listed above aren't orthogonal,
            and multi-paradigm languages are a thing.
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
            ## What is functional programming?
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            Programming with functions!
            </script>
          </section>
          <section>
            <img data-src="f-of-x.jpg" style="background-color:white;"/>
          </section>
          <section data-markdown>
            <script type="text/template">
            > Functional programming is a programming paradigm
            > that treats computation as the evaluation of
            > mathematical functions and avoids state and mutable data

            <small>https://en.wikipedia.org/wiki/Functional_programming</small>
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            ### What doesn't it look like?
            ```
            const calculateTax = (amount) => {
              var taxRate = db.getTaxRate()
              return taxRate / amount * 100
            }
            ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            ### What doesn't it look like?
            ```
            const calculateTax = (amount, taxRate) => {
              var tax = taxRate / amount * 100
              db.addTotalTax(tax)
              return tax
            }
            ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            The above snippets of code aren't 'pure functions' ...
            </script>
          </section>
        </section>

        <section>
          <section>
            <h2>Purity</h2>
            <img data-src="input->output.png" style="background-color:white;"/>
            <p>
            <small>
              <a href="https://www.fpcomplete.com/blog/2017/04/pure-functional-programming">(source)</a></small>
            </p>
          </section>
          <section data-markdown>
            <script type="text/template">
            Same arguments in === same result
            <p class="fragment">No side effects!</p>
            </script>
          </section>
          <section>
            <h3>An example ...</h3>
            <p>Let's write some code to double every number in a list:<p>
            <div class="fragment" data-markdown>
              <script type="text/template">
              ```javascript
              const multiplyByTwo = (numbers) => {
                for(var i = 0; i < numbers.length; i++) {
                  numbers[i] = numbers[i] * 2
                }
                return numbers
              }
              ```
              </script>
            </div>
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            ### An example ...
            <pre class="highlight javascript">
            var oneToFive = [1, 2, 3, 4, 5]
            var doubled = multiplyByTwo(oneToFive)
            console.log(doubled)   // -> '[2, 4, 6, 8, 10]'  ...  :)
            <span class="fragment">console.log(oneToFive) // -> '[2, 4, 6, 8, 10]'  ...  :(</span>
            </pre>
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            ### An example ...
            <pre class="highlight javascript">
            const multiplyByTwo = (numbers) => {
              var destination = []
              for(var i = 0; i < numbers.length; i++) {
                destination.push(numbers[i] * 2)
              }
              return destination
            }
            </pre>
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            ### An example ...
            <pre class="highlight javascript">
            var oneToFive = [1, 2, 3, 4, 5]
            var doubled = multiplyByTwo(oneToFive)
            console.log(doubled)   // -> '[2, 4, 6, 8, 10]'  ...  :)
            console.log(oneToFive) // -> '[1, 2, 3, 4, 5]'   ...  :)
            </pre>
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            Pure functions are easier to design, test and understand
            </script>
          </section>
          <section data-markdown data-transition="none">
            <script type="text/template">
            #### Referential transparency
            ```javascript
            const getMeATea = () => {
              // ...
            }

            var tea1 = getMeATea()
            var tea2 = getMeATea()
            var tea3 = getMeATea()
            ```

            Note:
            Referential transparency means that an expression always evaluates to the same
            result in any context, so you can replace an expression with its value
            anywhere you see the expression

            This makes it very easy to debug programs, as you can easily make subtitutions
            and be sure that you haven't changed the outcome of your program.
            </script>
          </section>
          <section data-markdown data-transition="none">
            <script type="text/template">
            #### Referential transparency
            ```javascript
            const getMeATea = () => {
              // ...
            }

            var tea1 = getMeATea()
            var tea2 = tea1
            var tea3 = tea1
            ```
            </script>
          </section>
          <section data-markdown data-transition="none">
            <script type="text/template">
            #### Referential transparency
            ```javascript
            const getMeATea = () => {
              val cup = new Tea()
              creditCard.charge(cup.price)
              return cup
            }

            var tea1 = getMeATea()
            var tea2 = tea1
            var tea3 = tea1
            ```
            <span class="fragment">Free tea?!</span>

            Note:
            So if `getMeATea` performs side effects, it's not longer referentially
            transparent, and you can't use the substitution model to reason about the
            evaluation of your program.
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
            ## `multiplyByTwo` revisited
            </script>
          </section>
          <section data-markdown data-transition="none">
            <script type="text/template">
            ```javascript
            const multiplyByTwo = (input) => {
              var destination = []
              for(var i = 0; i < input.length; i++) {
                destination.push(input[i] * 2)
              }
              return destination
            }

            console.log(multiplyByTwo([1, 2, 3, 4, 5]))
              // -> '[2, 4, 6, 8, 10]'
            ```

            Note:
            This is now a pure function, in that its output depends solely on its
            input and it has no side effects observable from outside the function.

            But, there is state here - `destination` and `i` are mutated.
            </script>
          </section>
          <section data-markdown data-transition="none">
            <script type="text/template">
            ```javascript
            const shout = (input) => {
              var destination = []
              for(var i = 0; i < input.length; i++) {
                destination.push(input[i].toUpperCase() + "!")
              }
              return destination
            }

            console.log(shout(["just", "some", "words"]))
              // -> '["JUST!", "SOME!", "WORDS!"]'
            ```
            </script>
          </section>
          <section data-markdown data-transition="none">
            <script type="text/template">
            ```
            const map = (input, fn) => {
              var destination = []
              for(var i = 0; i < input.length; i++) {
                destination.push(fn(input[i]))
              }
              return destination
            }
            ```
            </script>
          </section>
          <section data-markdown data-transition="none">
            <script type="text/template">
            ```javascript
            console.log(
              map(["a", "b", "c", "d", "e"], i => i.toUpperCase() + "!")
            )
            // -> ["A!", "B!", "C!", "D!", "E!"]

            console.log(
              map([1, 2, 3, 4, 5], i => return i * 2)
            )
            // -> [2, 4, 6, 8, 10]
            ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            A higher order function is one that takes one or more functions as
            input, or returns a function.

            Note:
            Higher order functions all us to be more declarative in our code,
            we just say 'apply this function to the elements in this list',
            rather than specifying exactly how that should happen.
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
            ## Common higher-order functions
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            **`map`** is the name of a higher-order function that applies a given
            function to each element of a list, returning a list of results
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            **`filter`** is a higher-order function that processes a collection to produce
            a new collection containing exactly those elements of the original collection
            for which a given predicate returns true
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            ```javascript
            console.log([1, 2, 3, 4].filter(i => i % 2 == 0))
            // -> [2, 4]
            ```
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            *`fold`* / *`reduce`* / *`aggregate`* are a family of higher-order functions that
            analyse a recursive data structure and recombine through use of a given
            combining operation the results of recursively processing its constituent
            parts, building up a return value
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            ```javascript
            console.log(
              [1, 2, 3, 4, 5].reduce(
                (accumulator, i) => accumulator + i,
                0
              )
            )
            // -> 15
            ```
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
            ## Declarative programming
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
            What does this do?
            ```javascript
            var n = 1;
            var num_elements = 0;
            var result = 0;

            while (num_elements < 10) {
              result += (n * n);
              num_elements += 1;
              n += 1;
            }

            console.log(result) // -> 385
            ```
            </script>
          </section>
          <section>
            <p>How about this?</p>
            <pre class="highlight haskell">
<span class="fragment" data-fragment-index=0>[1..]</span><span class="fragment" data-fragment-index=1>  |> map (^2)</span><span class="fragment" data-fragment-index=2>  |> take 10</span><span class="fragment" data-fragment-index=3>  |> sum</span><span class="fragment" data-fragment-index=4>  |> print</span></pre>
            <small>(apologies for the Haskell/F# syntax)</small>
          </section>
          <section data-markdown>
            <script type="text/template">
              We're telling the computer what we want, and not how to get it
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ### Why

              We abstract away concepts of iteration, transformation, filtering, and accumulation
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ### Why

              We can write functions to deal with elements, and not a collection
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              ### Why

              We get small independently testable functions are more maintainable
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
            </script>
          </section>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // More info https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
          { src: 'plugin/markdown/marked.js' },
          { src: 'plugin/markdown/markdown.js' },
          { src: 'plugin/notes/notes.js', async: true },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() {
            [].forEach.call( document.querySelectorAll( '.highlight' ), function( v, i) {
              hljs.highlightBlock(v);
            });
          } }
        ]
      });
    </script>
  </body>
</html>
